//!
//! Some helper functions that can calculate special layouts.
//!
use ratatui::layout::{Constraint, Direction, Flex, Layout, Margin, Rect};
use std::cmp::{max, min};

/// Constraint data for [layout_edit]
#[allow(variant_size_differences)]
#[derive(Debug)]
pub enum EditConstraint<'a> {
    /// Label by sample
    Label(&'a str),
    /// Label by width. (cols)
    LabelWidth(u16),
    /// Label by height+width. ( cols, rows).
    LabelRows(u16, u16),
    /// Label occupying the full row.
    TitleLabel,
    /// Label occupying the full row, but rendering only part of it. (cols)
    TitleLabelWidth(u16),
    /// Label occupying the full row. (rows)
    TitleLabelRows(u16),
    /// Widget aligned with the label. (cols)
    Widget(u16),
    /// Widget aligned with the label. (cols, rows)
    WidgetRows(u16, u16),
    /// Empty line. Only increase the line counter.
    Empty,
    /// Empty line. (rows).  Only increase the line counter.
    EmptyRows(u16),
    /// Widget aligned with the left margin. (cols)
    LineWidget(u16),
    /// Widget aligned with the left margin. (cols, rows)
    LineWidgetRows(u16, u16),
}

/// Layout generated by [layout_edit]
#[derive(Debug, Default)]
pub struct LayoutEdit {
    label: Vec<Option<Rect>>,
    widget: Vec<Option<Rect>>,
}

impl LayoutEdit {
    /// Returns label number n.
    /// Panics if out of bounds or if there is no label at this position.
    pub fn label(&self, n: usize) -> Rect {
        self.label[n].expect("layout-error")
    }

    /// Returns widget number n.
    /// Panics if out of bounds or if there is no widget at this position.
    pub fn widget(&self, n: usize) -> Rect {
        self.widget[n].expect("layout-error")
    }

    pub fn iter(&self) -> LayoutEditIterator<'_> {
        LayoutEditIterator {
            l: self,
            idx_label: 0,
            idx_widget: 0,
        }
    }
}

#[derive(Debug)]
pub struct LayoutEditIterator<'a> {
    idx_label: usize,
    idx_widget: usize,
    l: &'a LayoutEdit,
}

impl<'a> LayoutEditIterator<'a> {
    /// Next widget.
    ///
    /// Panic
    /// Panics if there are no more widgets.
    #[track_caller]
    pub fn widget(&mut self) -> Rect {
        let widget = self.l.widget.get(self.idx_widget).expect("no_more_widget");

        // skip layout if there was no layout for it.
        if self.idx_label < self.l.label.len() {
            if self.l.label[self.idx_label].is_none() {
                self.idx_label += 1;
            }
        }

        self.idx_widget += 1;

        widget.expect("layout-error")
    }

    /// Next label.
    ///
    /// Panic
    /// Panics if there are no more labels.
    #[track_caller]
    pub fn label(&mut self) -> Rect {
        let label = self.l.label.get(self.idx_label).expect("no_more_label");

        // skip widget if there was no layout for it.
        if self.idx_widget < self.l.widget.len() {
            if self.l.widget[self.idx_widget].is_none() {
                self.idx_widget += 1;
            }
        }

        self.idx_label += 1;

        label.expect("layout-error")
    }
}

/// Simple layout for an edit mask.
/// It creates one column of input widgets and aligns the labels.
#[allow(clippy::comparison_chain)]
pub fn layout_edit(area: Rect, constraints: &[EditConstraint<'_>]) -> LayoutEdit {
    let mut max_label = 0;
    let mut max_widget = 0;
    let mut space = 1;

    for l in constraints.iter() {
        match l {
            EditConstraint::Label(s) => {
                max_label = max(max_label, s.len() as u16);
            }
            EditConstraint::LabelWidth(w) => {
                max_label = max(max_label, *w);
            }
            EditConstraint::LabelRows(w, _) => {
                max_label = max(max_label, *w);
            }
            EditConstraint::TitleLabel => {
                // don't count
            }
            EditConstraint::TitleLabelWidth(_) => {
                // don't count
            }
            EditConstraint::TitleLabelRows(_) => {
                // don't count
            }
            EditConstraint::Widget(w) => {
                max_widget = max(max_widget, *w);
            }
            EditConstraint::WidgetRows(w, _) => {
                max_widget = max(max_widget, *w);
            }
            EditConstraint::LineWidget(_) => {
                // don't count
            }
            EditConstraint::LineWidgetRows(_, _) => {
                // don't count
            }
            EditConstraint::Empty => {}
            EditConstraint::EmptyRows(_) => {}
        }
    }

    let mut result = LayoutEdit::default();

    // area.width is a constraint too
    if max_label + space + max_widget < area.width {
        space = area.width - max_label - max_widget;
    } else if max_label + space + max_widget > area.width {
        let mut reduce = max_label + space + max_widget - area.width;

        if space > reduce {
            space -= reduce;
            reduce = 0;
        } else {
            reduce -= space;
            space = 0;
        }
        if max_label > 5 {
            if max_label - 5 > reduce {
                max_label -= reduce;
                reduce = 0;
            } else {
                reduce -= max_label - 5;
                max_label = 5;
            }
        }
        if max_widget > 5 {
            if max_widget - 5 > reduce {
                max_widget -= reduce;
                reduce = 0;
            } else {
                reduce -= max_widget - 5;
                max_widget = 5;
            }
        }
        if max_label > reduce {
            max_label -= reduce;
            reduce = 0;
        } else {
            reduce -= max_label;
            max_label = 0;
        }
        if max_widget > reduce {
            max_widget -= reduce;
            // reduce = 0;
        } else {
            // reduce -= max_widget;
            max_widget = 0;
        }
    }

    let mut x = area.x;
    let mut y = area.y;
    let total = max_label + space + max_widget;
    let mut rest_height = if area.height > 0 { area.height - 1 } else { 0 }; //todo: verify the '-1' somehow??
    let mut height = min(1, rest_height);

    for l in constraints.iter() {
        // break before
        match l {
            EditConstraint::LineWidget(_) | EditConstraint::LineWidgetRows(_, _) => {
                if x != area.x {
                    x = area.x;
                    y += height;
                    rest_height -= height;
                    height = min(1, rest_height);
                }
            }
            EditConstraint::TitleLabel
            | EditConstraint::TitleLabelWidth(_)
            | EditConstraint::TitleLabelRows(_) => {
                if x != area.x {
                    x = area.x;
                    y += height;
                    rest_height -= height;
                    height = min(1, rest_height);
                }
            }
            EditConstraint::Label(_)
            | EditConstraint::LabelWidth(_)
            | EditConstraint::LabelRows(_, _)
            | EditConstraint::Widget(_)
            | EditConstraint::WidgetRows(_, _)
            | EditConstraint::Empty
            | EditConstraint::EmptyRows(_) => {}
        }

        // self
        match l {
            EditConstraint::Label(s) => {
                result.label.push(Some(Rect::new(
                    x,
                    y,
                    min(s.len() as u16, max_label),
                    min(1, rest_height),
                )));
            }
            EditConstraint::LabelWidth(w) => {
                result.label.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_label),
                    min(1, rest_height),
                )));
            }
            EditConstraint::LabelRows(w, h) => {
                result
                    .label
                    .push(Some(Rect::new(x, y, min(*w, max_label), min(1, *h))));
            }
            EditConstraint::TitleLabel => {
                result
                    .label
                    .push(Some(Rect::new(x, y, total, min(1, rest_height))));
                result.widget.push(None);
            }
            EditConstraint::TitleLabelWidth(w) => {
                result.label.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_label),
                    min(1, rest_height),
                )));
                result.widget.push(None);
            }
            EditConstraint::TitleLabelRows(h) => {
                result
                    .label
                    .push(Some(Rect::new(x, y, total, min(*h, rest_height))));
                result.widget.push(None);
            }
            EditConstraint::Widget(w) => {
                result.widget.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_widget),
                    min(1, rest_height),
                )));
            }
            EditConstraint::WidgetRows(w, h) => {
                result.widget.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_widget),
                    min(*h, rest_height),
                )));
            }
            EditConstraint::LineWidget(w) => {
                result.label.push(None);
                result.widget.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_widget),
                    min(1, rest_height),
                )));
            }
            EditConstraint::LineWidgetRows(w, h) => {
                result.label.push(None);
                result.widget.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_widget),
                    min(*h, rest_height),
                )));
            }
            EditConstraint::Empty => {}
            EditConstraint::EmptyRows(_) => {}
        }

        // row-height
        match l {
            EditConstraint::Label(_)
            | EditConstraint::LabelWidth(_)
            | EditConstraint::TitleLabel
            | EditConstraint::TitleLabelWidth(_)
            | EditConstraint::Widget(_)
            | EditConstraint::Empty
            | EditConstraint::LineWidget(_) => {
                height = min(max(height, 1), rest_height);
            }
            EditConstraint::LabelRows(_, h)
            | EditConstraint::TitleLabelRows(h)
            | EditConstraint::WidgetRows(_, h)
            | EditConstraint::EmptyRows(h)
            | EditConstraint::LineWidgetRows(_, h) => {
                height = min(max(height, *h), rest_height);
            }
        }

        // break after
        match l {
            EditConstraint::Label(_)
            | EditConstraint::LabelWidth(_)
            | EditConstraint::LabelRows(_, _) => {
                x += max_label + space;
            }
            EditConstraint::TitleLabel
            | EditConstraint::TitleLabelWidth(_)
            | EditConstraint::TitleLabelRows(_) => {
                x = area.x;
                y += height;
                rest_height -= height;
                height = min(1, rest_height);
            }
            EditConstraint::Widget(_)
            | EditConstraint::WidgetRows(_, _)
            | EditConstraint::Empty
            | EditConstraint::EmptyRows(_)
            | EditConstraint::LineWidget(_)
            | EditConstraint::LineWidgetRows(_, _) => {
                x = area.x;
                y += height;
                rest_height -= height;
                height = min(1, rest_height);
            }
        };
    }

    result
}

/// Layout produced by [layout_dialog]
#[derive(Debug)]
pub struct LayoutDialog<const N: usize> {
    pub dialog: Rect,
    pub area: Rect,
    pub button_area: Rect,
    pub buttons: [Rect; N],
}

impl<const N: usize> LayoutDialog<N> {
    pub fn button(&self, n: usize) -> Rect {
        self.buttons[n]
    }
}

/// Calculates a layout for a dialog with buttons.
pub fn layout_dialog<const N: usize>(
    area: Rect,
    h_constraint: Constraint,
    v_constraint: Constraint,
    insets: Margin,
    buttons: [Constraint; N],
    button_spacing: u16,
    button_flex: Flex,
) -> LayoutDialog<N> {
    let l_vertical = Layout::new(
        Direction::Vertical,
        [Constraint::Fill(1), v_constraint, Constraint::Fill(1)],
    )
    .split(area);
    let l_dialog = Layout::new(
        Direction::Horizontal,
        [Constraint::Fill(1), h_constraint, Constraint::Fill(1)],
    )
    .split(l_vertical[1])[1];

    let l_inner = l_dialog.inner(&insets);

    let l_content = Layout::vertical([
        Constraint::Fill(1),
        Constraint::Length(insets.vertical),
        Constraint::Length(1),
    ])
    .split(l_inner);

    let l_buttons = Layout::horizontal(buttons)
        .spacing(button_spacing)
        .flex(button_flex)
        .areas(l_content[2]);

    LayoutDialog {
        dialog: l_dialog,
        area: l_inner,
        button_area: l_content[2],
        buttons: l_buttons,
    }
}
