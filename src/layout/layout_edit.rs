//!
//! Calculate the layout for an edit-mask with lots of label/widget pairs.
//!

use ratatui::layout::Rect;
use std::cmp::{max, min};

/// Constraint data for [layout_edit]
#[allow(variant_size_differences)]
#[derive(Debug)]
pub enum EditConstraint<'a> {
    /// Label by sample
    Label(&'a str),
    /// Label by width. (cols)
    LabelWidth(u16),
    /// Label by height+width. ( cols, rows).
    LabelRows(u16, u16),
    /// Label occupying the full row.
    TitleLabel,
    /// Label occupying the full row, but rendering only part of it. (cols)
    TitleLabelWidth(u16),
    /// Label occupying multiple full rows. (rows)
    TitleLabelRows(u16),
    /// Widget aligned with the label. (cols)
    Widget(u16),
    /// Widget aligned with the label. (cols, rows)
    WidgetRows(u16, u16),
    /// Empty line. Only increase the line counter.
    Empty,
    /// Empty lines. (rows). Only increase the line counter.
    EmptyRows(u16),
    /// Widget aligned with the left margin. (cols)
    LineWidget(u16),
    /// Widget aligned with the left margin. (cols, rows)
    LineWidgetRows(u16, u16),
}

/// Layout generated by [layout_edit]
#[derive(Debug, Default)]
pub struct LayoutEdit {
    label: Vec<Option<Rect>>,
    widget: Vec<Option<Rect>>,
}

impl LayoutEdit {
    /// Returns label number n.
    /// Panics if out of bounds or if there is no label at this position.
    pub fn label(&self, n: usize) -> Rect {
        self.label[n].expect("layout-error")
    }

    /// Returns widget number n.
    /// Panics if out of bounds or if there is no widget at this position.
    pub fn widget(&self, n: usize) -> Rect {
        self.widget[n].expect("layout-error")
    }

    /// Returns the label nr at the given position.
    pub fn label_at(&self, pos: (u16, u16)) -> Option<usize> {
        let mut nr = 0;
        for i in 0..self.widget.len() {
            if let Some(label) = self.label[i] {
                if label.contains(pos.into()) {
                    return Some(nr);
                }
                nr += 1;
            }
        }
        None
    }

    /// Returns the widget nr at the given position.
    pub fn widget_at(&self, pos: (u16, u16)) -> Option<usize> {
        let mut nr = 0;
        for i in 0..self.widget.len() {
            if let Some(widget) = self.widget[i] {
                if widget.contains(pos.into()) {
                    return Some(nr);
                }
                nr += 1;
            }
        }
        None
    }

    /// Create an iterator look-alike that gives access to both
    /// label and widget areas.
    ///
    /// If you render your widgets in the order of the layout, you
    /// don't need widget indexes any longer.
    pub fn iter(&self) -> LayoutEditIterator<'_> {
        LayoutEditIterator {
            l: self,
            idx_label: 0,
            idx_widget: 0,
        }
    }
}

/// Iterates both the labels and the widgets.
///
/// You have to call both to keep the iterator in sync.
/// For `TitleLable` and `RowWidget` you need only `label()` or
/// `widget()` respectively.
///
#[derive(Debug)]
pub struct LayoutEditIterator<'a> {
    idx_label: usize,
    idx_widget: usize,
    l: &'a LayoutEdit,
}

impl<'a> LayoutEditIterator<'a> {
    /// Next widget.
    ///
    /// Panic
    /// Panics if there are no more widgets.
    #[track_caller]
    pub fn widget(&mut self) -> Rect {
        let widget = self.l.widget.get(self.idx_widget).expect("no_more_widget");

        // skip layout if there was no layout for it.
        if self.idx_label < self.l.label.len() {
            if self.l.label[self.idx_label].is_none() {
                self.idx_label += 1;
            }
        }

        self.idx_widget += 1;

        widget.expect("layout-error")
    }

    /// Next label.
    ///
    /// Panic
    /// Panics if there are no more labels.
    #[track_caller]
    pub fn label(&mut self) -> Rect {
        let label = self.l.label.get(self.idx_label).expect("no_more_label");

        // skip widget if there was no layout for it.
        if self.idx_widget < self.l.widget.len() {
            if self.l.widget[self.idx_widget].is_none() {
                self.idx_widget += 1;
            }
        }

        self.idx_label += 1;

        label.expect("layout-error")
    }
}

/// Layout for an edit mask with lots of label+widget pairs.
///
/// This neatly aligns labels and widgets in one column.
///
#[allow(clippy::comparison_chain)]
pub fn layout_edit(area: Rect, constraints: &[EditConstraint<'_>]) -> LayoutEdit {
    let mut max_label = 0;
    let mut max_widget = 0;
    let mut space = 1;

    for l in constraints.iter() {
        match l {
            EditConstraint::Label(s) => {
                max_label = max(max_label, s.len() as u16);
            }
            EditConstraint::LabelWidth(w) => {
                max_label = max(max_label, *w);
            }
            EditConstraint::LabelRows(w, _) => {
                max_label = max(max_label, *w);
            }
            EditConstraint::TitleLabel => {
                // don't count
            }
            EditConstraint::TitleLabelWidth(_) => {
                // don't count
            }
            EditConstraint::TitleLabelRows(_) => {
                // don't count
            }
            EditConstraint::Widget(w) => {
                max_widget = max(max_widget, *w);
            }
            EditConstraint::WidgetRows(w, _) => {
                max_widget = max(max_widget, *w);
            }
            EditConstraint::LineWidget(_) => {
                // don't count
            }
            EditConstraint::LineWidgetRows(_, _) => {
                // don't count
            }
            EditConstraint::Empty => {}
            EditConstraint::EmptyRows(_) => {}
        }
    }

    let mut result = LayoutEdit::default();

    // area.width is a constraint too
    if max_label + space + max_widget < area.width {
        space = area.width - max_label - max_widget;
    } else if max_label + space + max_widget > area.width {
        let mut reduce = max_label + space + max_widget - area.width;

        if space > reduce {
            space -= reduce;
            reduce = 0;
        } else {
            reduce -= space;
            space = 0;
        }
        if max_label > 5 {
            if max_label - 5 > reduce {
                max_label -= reduce;
                reduce = 0;
            } else {
                reduce -= max_label - 5;
                max_label = 5;
            }
        }
        if max_widget > 5 {
            if max_widget - 5 > reduce {
                max_widget -= reduce;
                reduce = 0;
            } else {
                reduce -= max_widget - 5;
                max_widget = 5;
            }
        }
        if max_label > reduce {
            max_label -= reduce;
            reduce = 0;
        } else {
            reduce -= max_label;
            max_label = 0;
        }
        if max_widget > reduce {
            max_widget -= reduce;
            // reduce = 0;
        } else {
            // reduce -= max_widget;
            max_widget = 0;
        }
    }

    let mut x = area.x;
    let mut y = area.y;
    let total = max_label + space + max_widget;
    let mut rest_height = if area.height > 0 { area.height - 1 } else { 0 }; //todo: verify the '-1' somehow??
    let mut height = min(1, rest_height);

    for l in constraints.iter() {
        // break before
        match l {
            EditConstraint::LineWidget(_) | EditConstraint::LineWidgetRows(_, _) => {
                if x != area.x {
                    x = area.x;
                    y += height;
                    rest_height -= height;
                    height = min(1, rest_height);
                }
            }
            EditConstraint::TitleLabel
            | EditConstraint::TitleLabelWidth(_)
            | EditConstraint::TitleLabelRows(_) => {
                if x != area.x {
                    x = area.x;
                    y += height;
                    rest_height -= height;
                    height = min(1, rest_height);
                }
            }
            EditConstraint::Label(_)
            | EditConstraint::LabelWidth(_)
            | EditConstraint::LabelRows(_, _)
            | EditConstraint::Widget(_)
            | EditConstraint::WidgetRows(_, _)
            | EditConstraint::Empty
            | EditConstraint::EmptyRows(_) => {}
        }

        // self
        match l {
            EditConstraint::Label(s) => {
                result.label.push(Some(Rect::new(
                    x,
                    y,
                    min(s.len() as u16, max_label),
                    min(1, rest_height),
                )));
            }
            EditConstraint::LabelWidth(w) => {
                result.label.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_label),
                    min(1, rest_height),
                )));
            }
            EditConstraint::LabelRows(w, h) => {
                result
                    .label
                    .push(Some(Rect::new(x, y, min(*w, max_label), min(1, *h))));
            }
            EditConstraint::TitleLabel => {
                result
                    .label
                    .push(Some(Rect::new(x, y, total, min(1, rest_height))));
                result.widget.push(None);
            }
            EditConstraint::TitleLabelWidth(w) => {
                result.label.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_label),
                    min(1, rest_height),
                )));
                result.widget.push(None);
            }
            EditConstraint::TitleLabelRows(h) => {
                result
                    .label
                    .push(Some(Rect::new(x, y, total, min(*h, rest_height))));
                result.widget.push(None);
            }
            EditConstraint::Widget(w) => {
                result.widget.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_widget),
                    min(1, rest_height),
                )));
            }
            EditConstraint::WidgetRows(w, h) => {
                result.widget.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_widget),
                    min(*h, rest_height),
                )));
            }
            EditConstraint::LineWidget(w) => {
                result.label.push(None);
                result.widget.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_widget),
                    min(1, rest_height),
                )));
            }
            EditConstraint::LineWidgetRows(w, h) => {
                result.label.push(None);
                result.widget.push(Some(Rect::new(
                    x,
                    y,
                    min(*w, max_widget),
                    min(*h, rest_height),
                )));
            }
            EditConstraint::Empty => {}
            EditConstraint::EmptyRows(_) => {}
        }

        // row-height
        match l {
            EditConstraint::Label(_)
            | EditConstraint::LabelWidth(_)
            | EditConstraint::TitleLabel
            | EditConstraint::TitleLabelWidth(_)
            | EditConstraint::Widget(_)
            | EditConstraint::Empty
            | EditConstraint::LineWidget(_) => {
                height = min(max(height, 1), rest_height);
            }
            EditConstraint::LabelRows(_, h)
            | EditConstraint::TitleLabelRows(h)
            | EditConstraint::WidgetRows(_, h)
            | EditConstraint::EmptyRows(h)
            | EditConstraint::LineWidgetRows(_, h) => {
                height = min(max(height, *h), rest_height);
            }
        }

        // break after
        match l {
            EditConstraint::Label(_)
            | EditConstraint::LabelWidth(_)
            | EditConstraint::LabelRows(_, _) => {
                x += max_label + space;
            }
            EditConstraint::TitleLabel
            | EditConstraint::TitleLabelWidth(_)
            | EditConstraint::TitleLabelRows(_) => {
                x = area.x;
                y += height;
                rest_height -= height;
                height = min(1, rest_height);
            }
            EditConstraint::Widget(_)
            | EditConstraint::WidgetRows(_, _)
            | EditConstraint::Empty
            | EditConstraint::EmptyRows(_)
            | EditConstraint::LineWidget(_)
            | EditConstraint::LineWidgetRows(_, _) => {
                x = area.x;
                y += height;
                rest_height -= height;
                height = min(1, rest_height);
            }
        };
    }

    result
}
